import jaci.gradle.toolchains.*
import jaci.gradle.nativedeps.*

apply plugin: 'jaci.gradle.EmbeddedTools'

// Change the line below if you change the name of your main Java class.
// Reminder: full declaration of name, i.e.: include packages
def mainClass = 'org.usfirst.frc.team1089.main.Main'

def jarName = "vision"

configurations {
    vision
}

dependencies {
    vision fileTree(dir: 'lib/natives', include: '*.so')
}

deploy {
    targets {
        target('rpi') {
            addresses << '10.10.89.20:5802' << '10.10.89.20'
            user = 'pi'
            password = 'raspberry'
            directory = 'output'
            failOnMissing = false
            timeout = 10
        }
    }

    artifacts {
        javaArtifact('visionArtifact') {
            targets << 'rpi'
            filename = "${jarName}.jar"
            jar = 'jar'

            predeploy << {
                execute 'rm -rf /home/pi/output'
            }

            postdeploy << {
                execute "echo \"java -Djava.library.path=. -jar ${jarName}.jar\" >> /home/pi/output/runVision"
                execute 'chmod 755 /home/pi/output/runVision'
            }
        }

        // Using a fileCollectionArtifact for deploying so's.
        // Bad practice, I think.
        fileCollectionArtifact('nativeCollectionArtifact') {
            targets << 'rpi'
            files = fileTree(dir: 'lib/natives', include: '*.so')      // Set the filecollection (e.g. filetree, files, etc) to deploy. Required
        }
    }
}

jar {
    from configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
    // I need to set my manifest up so the coprocessor knows where my main class is
    manifest {
        attributes 'Main-Class': mainClass
    }
}